## SYSTEM DESIGN

### 后台流程管理方式

使用有限状态机进行管理。

#### 状态设置

包括的主要状态为：

- init
- record
- task

其中，record是录制状态，task是执行某一个任务，init是初始状态。

基本的转换为，init->task，如果判断是新的task则转换到record，也可以直接从init->record

#### Transform`对象

包含三个部分，

```jso
{
	"trigger":"", // 触发的事件
	"next_state":"", // 下一个状态
	"leave":"" // 离开当前状态时的回调函数
}
```

#### `Event`对象

```json
{
    "query": "",//用户输入的内容
    "data": {}, //附加的信息
}
```



#### 转换方式

对于某一个状态$s$​​​, 一个`Event`到来后，状态机会遍历当前的`Transform`列表，将`Event`传入`trigger`函数中判断是否符合状态转移的规则。如果符合，那么调用对应的`leave`回调来处理离开时间，然后转移到新的状态，并触发进入状态的函数（以`enter_`开头的函数）。

进入状态的函数主要做两件事：

1. 生成回复
2. 创建当前状态的`Transform`列表

### 任务设计

任务保存形式：

```json
{
    "id":"",// 唯一标志
    "name":"",//名字
    "trigger":[""],//触发语
    "action":[...]
}
```

添加任务的方式 ：

- 录制新任务
- 触发了一个不认识的任务并开始录制
- 将utterance绑定到已知的任务中



### 双演示解析

每个任务需要录制两个演示，每个演示需要使用不同的参数。通过对比两个演示解析操作：

- 两个演示都有的操作（对某一个元素的某一个操作）被认定成固定操作，以后执行都会有
- 两个演示不同的操作（和slot value相关的操作）需要对比两个ui的差异，找到包含slot文字和操作对象的框，然后找到两个操作的最小父节点



### 添加用户系统后需要修改的地方

#### 保存动作的时候根据用户名来命名文件，防止冲突

